@page "/export"
@using System
@using Daily_Journal_App.Services
@using Daily_Journal_App.Models
@inject JournalService JournalService
@inject IJSRuntime JS

<div style="max-width: 900px; margin: 0 auto; padding: 1rem;">
    <h2>Export Journal Entries</h2>
    <p>Select a single entry to export as PDF, or choose a date range.</p>

    <div class="card mb-3 p-3">
        <label>Export single entry (PDF)</label>
        <select class="form-select" @bind="selectedEntryId">
            <option value="0">-- Select entry --</option>
            @foreach (var e in allEntries)
            {
                <option value="@e.Id">@e.Date.ToString("yyyy-MM-dd") - @e.Title</option>
            }
        </select>
        <div class="mt-2">
            <button class="btn btn-primary" @onclick="ExportSelected">Export Selected (PDF)</button>
        </div>
    </div>

    <div class="card p-3">
        <label>Export by date range (PDF)</label>
        <div class="d-flex gap-2 align-items-end">
            <div>
                <label class="form-label">Start (yyyy-MM-dd)</label>
                <input type="text" class="form-control" @bind="startDateText" placeholder="2024-01-01" />
            </div>
            <div>
                <label class="form-label">End (yyyy-MM-dd)</label>
                <input type="text" class="form-control" @bind="endDateText" placeholder="2024-12-31" />
            </div>
            <div>
                <button class="btn btn-primary" @onclick="ExportRange">Export Range (PDF)</button>
            </div>
        </div>
    </div>

    @if (!string.IsNullOrEmpty(message))
    {
        <div class="alert alert-info mt-3">@message</div>
    }
</div>

@code {
    private List<JournalEntry> allEntries = new();
    private int selectedEntryId = 0;
    private string message = "";
    private string startDateText = "";
    private string endDateText = "";

    protected override async Task OnInitializedAsync()
    {
        allEntries = await JournalService.GetEntriesAsync();
    }

    private string WrapForPdf(string bodyHtml)
    {
        // Minimal inline styles for readable PDF output
        return $"<div style=\"font-family: Arial, Helvetica, sans-serif; color:#111; padding:18px; max-width:800px;\">" +
               "<style>h1,h2,h3{font-family: Arial, Helvetica, sans-serif; color:#222;} .meta{color:#666; font-size:0.9rem; margin-bottom:12px;} section{margin-bottom:18px;} .tags{margin-top:12px; font-size:0.9rem; color:#444;} </style>" +
               bodyHtml +
               "</div>";
    }

    private async Task ExportSelected()
    {
        message = "";
        if (selectedEntryId <= 0)
        {
            message = "Please select an entry.";
            return;
        }

        var entry = await JournalService.GetEntryAsync(selectedEntryId);
        if (entry == null)
        {
            message = "Entry not found.";
            return;
        }

        var html = BuildHtml(entry);
        var wrapped = WrapForPdf(html);
        var filename = $"journal-{entry.Date:yyyy-MM-dd}.pdf";

        try
        {
            var result = await JS.InvokeAsync<bool>("exportHtmlToPdf", filename, wrapped);
            message = result ? "PDF export started." : "PDF export failed.";
        }
        catch (Exception ex)
        {
            message = $"Export failed: {ex.Message}";
        }
    }

    private async Task ExportRange()
    {
        message = "";
        if (!DateTime.TryParse(startDateText, out var startDate))
        {
            message = "Please enter a valid start date (yyyy-MM-dd).";
            return;
        }

        if (!DateTime.TryParse(endDateText, out var endDate))
        {
            message = "Please enter a valid end date (yyyy-MM-dd).";
            return;
        }

        if (endDate < startDate)
        {
            message = "End date must be after start date.";
            return;
        }

        var entries = await JournalService.GetEntriesByDateRangeAsync(startDate, endDate);
        if (!entries.Any())
        {
            message = "No entries in the selected range.";
            return;
        }

        // Build combined HTML
        var sb = new System.Text.StringBuilder();
        foreach (var e in entries.OrderBy(e => e.Date))
        {
            sb.Append(BuildHtml(e));
            sb.Append("<hr style=\"border:none;border-top:1px solid #ddd;margin:18px 0;\"/>");
        }

        var wrapped = WrapForPdf(sb.ToString());
        var filename = $"journal-{startDate:yyyy-MM-dd}_to_{endDate:yyyy-MM-dd}.pdf";

        try
        {
            var result = await JS.InvokeAsync<bool>("exportHtmlToPdf", filename, wrapped);
            message = result ? "PDF export started." : "PDF export failed.";
        }
        catch (Exception ex)
        {
            message = $"Export failed: {ex.Message}";
        }
    }

    private string BuildHtml(JournalEntry entry)
    {
        var tagsHtml = string.Empty;
        if (!string.IsNullOrWhiteSpace(entry.Tags))
        {
            var tags = entry.Tags.Split(',').Select(t => t.Trim()).Where(t => !string.IsNullOrEmpty(t));
            tagsHtml = $"<div class=\"tags\"><strong>Tags:</strong> {System.Net.WebUtility.HtmlEncode(string.Join(", ", tags))}</div>";
        }

        var secondary = string.Empty;
        if (!string.IsNullOrWhiteSpace(entry.SecondaryMoods))
        {
            secondary = $" (Secondary: {System.Net.WebUtility.HtmlEncode(entry.SecondaryMoods)})";
        }

        return $"<section><h2>{System.Net.WebUtility.HtmlEncode(entry.Title)}</h2>" +
               $"<div class=\"meta\"><em>{entry.Date:dddd, MMMM dd, yyyy}</em> — <strong>Primary mood:</strong> {System.Net.WebUtility.HtmlEncode(entry.PrimaryMood)}{secondary}</div>" +
               $"<div>{entry.Content}</div>" +
               tagsHtml +
               "</section>";
    }
}
